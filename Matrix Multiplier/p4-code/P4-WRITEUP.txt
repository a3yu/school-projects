                              ____________

                               P4 WRITEUP
                              ____________


- Name: (FILL THIS in)
- NetID: (THE kauf0095 IN kauf0095@umn.edu)

Answer the questions below according to the project specification. Write
your answers directly in this text file and submit it along with your
code.


PROBLEM 1: matata_OPTM()
========================

  Do your timing study on csel-atlas.cselabs.umn.edu


(A) Paste Source Code
~~~~~~~~~~~~~~~~~~~~~

  Paste a copy of your source code for the function `matata_OPTM()'

  int matata_VER4(matrix_t mat, matrix_t ans) {
  int n = mat.rows;
  memset(ans.data, 0, sizeof(int) * n*n);
  for(int k = 0; k<n;k++) {
  for(int i = 0; i<n;i++) {
    int x = MGET(mat,k,i);
  int div = n/4;
  for(int j = 0; j<div*4;j+=4) {
      MSET(ans,i,j,MGET(ans,i,j)+(MGET(mat,k,j)*x));
      MSET(ans,i,j+1,MGET(ans,i,j+1)+(MGET(mat,k,j+1)*x));
      MSET(ans,i,j+2,MGET(ans,i,j+2)+(MGET(mat,k,j+2)*x));
      MSET(ans,i,j+3,MGET(ans,i,j+3)+(MGET(mat,k,j+3)*x));
      /* MSET(ans,i,j+5,MGET(ans,i,j+5)+(MGET(mat,k,j+5)*x)); */
  }
  for(int j = div*4; j<n;j++) {
      MSET(ans,i,j,MGET(ans,i,j)+(MGET(mat,k,j)*x));
  }
  }
  }

  return 0;                                     
}


(B) Timing on csel-atlas
~~~~~~~~~~~~~~~~~~~~~~~~

  Paste a copy of the results of running `matata_benchmark' on
  csel-atlas.cselabs.umn.edu in the space below which shows how your
  performance optimizations improved on the baseline codes.

yu000694@csel-atlas:/home/yu000694/p4-code $ ./matata_benchmark 
==== Matrix A^T*A Benchmark Version 1 ====
  SIZE       BASE       OPTM  SPDUP   LOG2 FACTOR POINTS 
   171 3.5688e-02 1.2127e-02   2.94   1.56   1.00   1.56 
   196 5.3466e-02 1.8057e-02   2.96   1.57   1.15   1.80 
   256 1.5040e-01 4.1465e-02   3.63   1.86   1.50   2.78 
   320 2.8970e-01 7.8507e-02   3.69   1.88   1.87   3.52 
   801 6.7463e+00 1.1936e+00   5.65   2.50   4.68  11.70 
  1024 2.7171e+01 2.7012e+00  10.06   3.33   5.99  19.94 
RAW POINTS: 41.31
 _   _                 _   _           _   _       _____ _    ____ _____ _ 
| \ | | _____      __ | |_| |__   __ _| |_( )___  |  ___/ \  / ___|_   _| |
|  \| |/ _ \ \ /\ / / | __| '_ \ / _` | __|// __| | |_ / _ \ \___ \ | | | |
| |\  | (_) \ V  V /  | |_| | | | (_| | |_  \__ \ |  _/ ___ \ ___) || | |_|
|_| \_|\___/ \_/\_/    \__|_| |_|\__,_|\__| |___/ |_|/_/   \_\____/ |_| (_)

                             ...,?77??!~~~~!???77?<~.... 
                        ..?7`                           `7!.. 
                    .,=`          ..~7^`   I                  ?1. 
       ........  ..^            ?`  ..?7!1 .               ...??7 
      .        .7`        .,777.. .I.    . .!          .,7! 
      ..     .?         .^      .l   ?i. . .`       .,^ 
       b    .!        .= .?7???7~.     .>r .      .= 
       .,.?4         , .^         1        `     4... 
        J   ^         ,            5       `         ?<. 
       .%.7;         .`     .,     .;                   .=. 
       .+^ .,       .%      MML     F       .,             ?, 
        P   ,,      J      .MMN     F        6               4. 
        l    d,    ,       .MMM!   .t        ..               ,, 
        ,    JMa..`         MMM`   .         .!                .; 
         r   .M#            .M#   .%  .      .~                 ., 
       dMMMNJ..!                 .P7!  .>    .         .         ,, 
       .WMMMMMm  ?^..       ..,?! ..    ..   ,  Z7`        `?^..  ,, 
          ?THB3       ?77?!        .Yr  .   .!   ?,              ?^C 
            ?,                   .,^.` .%  .^      5. 
              7,          .....?7     .^  ,`        ?. 
                `<.                 .= .`'           1 
                ....dn... ... ...,7..J=!7,           ., 
             ..=     G.,7  ..,o..  .?    J.           F 
           .J.  .^ ,,,t  ,^        ?^.  .^  `?~.      F 
          r %J. $    5r J             ,r.1      .=.  .% 
          r .77=?4.    ``,     l ., 1  .. <.       4., 
          .$..    .X..   .n..  ., J. r .`  J.       `' 
        .?`  .5        `` .%   .% .' L.'    t 
        ,. ..1JL          .,   J .$.?`      . 
                1.          .=` ` .J7??7<.. .; 
                 JS..    ..^      L        7.: 
                   `> ..       J.  4. 
                    +   r `t   r ~=..G. 
                    =   $  ,.  J 
                    2   r   t  .; 
              .,7!  r   t`7~..  j.. 
              j   7~L...$=.?7r   r ;?1. 
               8.      .=    j ..,^   .. 
              r        G              . 
            .,7,        j,           .>=. 
         .J??,  `T....... %             .. 
      ..^     <.  ~.    ,.             .D 
    .?`        1   L     .7.........?Ti..l 
   ,`           L  .    .%    .`!       `j, 
 .^             .  ..   .`   .^  .?7!?7+. 1 
.`              .  .`..`7.  .^  ,`      .i.; 
.7<..........~<<3?7!`    4. r  `          G% 
                          J.` .!           % 
                            JiJ           .` 
                              .1.         J 
                                 ?1.     .'         
                                     7<..%

      ____    ____                        
   _ | ___|  | __ )  ___  _ __  _   _ ___ 
 _| ||___ \  |  _ \ / _ \| '_ \| | | / __|
|_   _|__) | | |_) | (_) | | | | |_| \__ \
  |_||____/  |____/ \___/|_| |_|\__,_|___/

TOTAL POINTS: 40 / 35


(C) Optimizations
~~~~~~~~~~~~~~~~~

  Describe in some detail the optimizations you used to speed the code
  up.  THE CODE SHOULD CONTAIN SOME COMMENTS already to describe these
  but in the section below, describe in English the techniques you used
  to make the code run faster.  Format your descriptions into discrete
  chunks such as.
        Optimization 1: Blah bla blah... This should make run
        faster because yakkety yakeety yak.

        Optimization 2: Blah bla blah... This should make run
        faster because yakkety yakeety yak.

        ...  Optimization N: Blah bla blah... This should make run
        faster because yakkety yakeety yak.
  Full credit solutions will have a least two optimizations and describe
  WHY these improved performance in at least a couple sentences.

Optimization 1: I re-ordered the the memory access pattern to favor cache by using row-majopr programming and 
iterating across the rows of the 2D array and adding values as it goes. This should make the program faster because the nature
of C favors row wise iteration rather than the strides that coincide with column wise iteration.

Optimization 2: I got rid of the computation of the transpose of the matrix because it was unnecessary to get the final product.
The simple way of doing this was just switching the indices whenever I needed the transpose of a certain index. A[x][y] -> A[y][x] (transpose).
This should make the program faster because it will reduce memory usage and overall cut down unneccesary computations that slow the program down (getting and setting the matrices).

Optimization 3: I used memset to zero out the ans matrix since it performs better than iteration.

Optimization 4: I additionally unrolled the loops as pipelined processors allow straight line code to perform better and faster than branch prediction.
This makes the program faster due to super scalar CPUs scheduling computations superior.




PROBLEM 2: Timing Search Algorithms
===================================

  Do your timing study on csel-atlas.cselabs.umn.edu. In most cases,
  report times larger than 1e-03 seconds as times shorter than this are
  unreliable. Run searches for more repetitions to lengthen run times.


(A) Min Size for Algorithmic Differences
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Determine the size of input array where one starts to see a measurable
  difference in the performance of the linear and logarithmic
  algorithms.  Produce a timing table which includes all algorithms
  which clearly demonstrates an uptick in the times associated with some
  while others remain much lower.  Identify what size this appears to be
  a occur. SHOW A TIMING TABLE to support your conclusions and ensure
  that the times reported are larger that 1e-03.

yu000694@csel-atlas:/home/yu000694/p4-code $ ./search_benchmark 1 15 1 la ll ba bt
LENGTH         SEARCHES       array          list           binary         tree           
2              4              1.400000E+01   1.400000E+01   1.400000E+01   1.300000E+01   
4              8              1.500000E+01   1.100000E+01   1.400000E+01   1.300000E+01   
8              16             1.700000E+01   2.000000E+01   1.800000E+01   1.600000E+01   
16             32             3.200000E+01   3.100000E+01   2.900000E+01   2.400000E+01   
32             64             8.700000E+01   1.020000E+02   7.200000E+01   5.600000E+01   
64             128            2.860000E+02   2.850000E+02   1.280000E+02   1.290000E+02   
128            256            1.068000E+03   1.144000E+03   2.370000E+02   2.320000E+02   
256            512            4.332000E+03   4.314000E+03   5.170000E+02   4.480000E+02   
512            1024           1.671300E+04   2.077500E+04   1.149000E+03   8.760000E+02   
1024           2048           6.836500E+04   1.918230E+05   2.394000E+03   1.859000E+03   
2048           4096           2.591240E+05   8.084880E+05   3.870000E+03   3.283000E+03   
4096           8192           9.668720E+05   3.641835E+06   8.285000E+03   6.970000E+03 

As noticed above, once input reached a length of 32~64, a stark difference between the logarthmic algorithms
presents itself. Prior to that, it seems that negligible differences are present, but margins seem to grow rapidly
at around this area as shown above.


(B) Linear Search in List vs Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Determine whether the linear array and linked list search remain
  approximately at the same performance level as size increases to large
  data or whether one begins to become favorable over other. Determine
  the approximate size at which this divergence becomes obvious. Discuss
  reasons WHY this difference arises.  SHOW A TIMING TABLE to support
  your conclusions and ensure that the times reported are larger that
  1e-03.
yu000694@csel-atlas:/home/yu000694/p4-code $ ./search_benchmark 1 20 5 la ll
LENGTH         SEARCHES       array          list           
2              20             1.700000E+01   7.000000E+00   
4              40             2.400000E+01   2.400000E+01   
8              80             5.400000E+01   5.400000E+01   
16             160            1.590000E+02   1.470000E+02   
32             320            4.740000E+02   4.690000E+02   
64             640            1.739000E+03   1.698000E+03   
128            1280           6.535000E+03   6.536000E+03   
256            2560           2.543800E+04   2.537600E+04   
512            5120           1.004360E+05   1.193190E+05   
1024           10240          4.009170E+05   1.056885E+06   
2048           20480          1.604781E+06   5.682691E+06   

It seems a clear difference appears at ~length 512. This difference arises due to the fact that a linkedlist
can only be slower than an array because it is performing the same task as it uses arrays, but with more computational overhead.



(C) Binary Search in Tree vs Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  Compare the binary array search and binary tree search on small to
  very large arrays. Determine if there is a size at which the
  performance of these two begins to diverge. If so, describe why this
  might be happening based on your understanding of the data structures
  and the memory system. If not, describe why you believe there is
  little performance difference between the two. SHOW A TIMING TABLE to
  support your conclusions and ensure that the times reported are larger
  that 1e-03.

  ####################### YOUR ANSWER HERE #########################

  ##################################################################


(D) Caching Effects on Algorithms
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  It is commonly believed that memory systems that feature a Cache will
  lead to arrays performing faster than linked structures such as Linked
  Lists and Binary Search Trees. Describe whether your timings confirm
  or refute this belief.  Address both types of algorithms in your
  answer:
  - What effects does Cache have on Linear Search in arrays and lists
    and why?
  - What effects does Cache have on Binary Search in arrays and trees
    and why?

LENGTH         SEARCHES       binary         tree           
2              40             1.900000E+01   2.300000E+01   
4              80             3.700000E+01   3.500000E+01   
8              160            7.500000E+01   5.200000E+01   
16             320            2.210000E+02   1.490000E+02   
32             640            6.700000E+02   4.990000E+02   
64             1280           1.388000E+03   1.273000E+03   
128            2560           2.655000E+03   2.495000E+03   
256            5120           5.489000E+03   4.793000E+03   
512            10240          1.146400E+04   9.913000E+03   
1024           20480          2.436500E+04   2.058200E+04   
2048           40960          5.149900E+04   4.355300E+04   
4096           81920          1.101400E+05   9.267400E+04   
8192           163840         2.433760E+05   2.021090E+05  


(E) OPTIONAL MAKEUP CREDIT
~~~~~~~~~~~~~~~~~~~~~~~~~~

  If you decided to make use of a table of function pointers/structs
  which is worth makeup credit, describe your basic design for this
  below.

  ####################### YOUR ANSWER HERE #########################

  ##################################################################
